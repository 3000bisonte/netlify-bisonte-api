/**
 * üöÄ TEST COMPLETO DE TODAS LAS RUTAS - BISONTEAPP.COM
 * 
 * Verifica exhaustivamente todas las p√°ginas y funcionalidades del sitio
 */

const https = require('https');
const fs = require('fs');

const PRODUCTION_URL = 'https://www.bisonteapp.com';
const TIMEOUT = 20000;

// Funci√≥n para hacer request HTTP con seguimiento de redirecciones
function makeRequest(url, path = '', followRedirects = true) {
    return new Promise((resolve, reject) => {
        const fullUrl = url + path;
        console.log(`üîç Testing: ${fullUrl}`);
        
        const req = https.get(fullUrl, { timeout: TIMEOUT }, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                // Si hay redirecci√≥n y queremos seguirla
                if (followRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                    const redirectUrl = res.headers.location.startsWith('http') 
                        ? res.headers.location 
                        : url + res.headers.location;
                    
                    console.log(`   ‚Ü™Ô∏è  Redirected to: ${redirectUrl}`);
                    
                    // Hacer seguimiento de la redirecci√≥n
                    const redirectReq = https.get(redirectUrl, { timeout: TIMEOUT }, (redirectRes) => {
                        let redirectData = '';
                        redirectRes.on('data', chunk => redirectData += chunk);
                        redirectRes.on('end', () => {
                            resolve({
                                status: redirectRes.statusCode,
                                originalStatus: res.statusCode,
                                data: redirectData,
                                headers: redirectRes.headers,
                                redirected: true,
                                redirectUrl: redirectUrl
                            });
                        });
                    });
                    
                    redirectReq.on('error', () => {
                        // Si falla la redirecci√≥n, devolver respuesta original
                        resolve({
                            status: res.statusCode,
                            data,
                            headers: res.headers,
                            redirected: true,
                            redirectFailed: true
                        });
                    });
                    
                    redirectReq.on('timeout', () => {
                        redirectReq.destroy();
                        resolve({
                            status: res.statusCode,
                            data,
                            headers: res.headers,
                            redirected: true,
                            redirectTimeout: true
                        });
                    });
                } else {
                    resolve({ 
                        status: res.statusCode, 
                        data,
                        headers: res.headers,
                        redirected: false
                    });
                }
            });
        });
        
        req.on('timeout', () => {
            req.destroy();
            reject(new Error(`Timeout after ${TIMEOUT}ms`));
        });
        
        req.on('error', (error) => {
            reject(error);
        });
    });
}

// Lista completa de rutas para probar
const routes = [
    // P√°ginas principales
    { name: 'üè† Home Page', path: '', critical: true },
    { name: 'üè† Home Route', path: '/home', critical: true },
    { name: 'üì± Login Page', path: '/login', critical: true },
    { name: 'üìù Register Page', path: '/register', critical: true },
    { name: 'üîÑ Recovery Page', path: '/recuperar', critical: false },
    { name: '‚úÖ Recovery Success', path: '/recuperar/exito', critical: false },
    { name: 'üîë Validate Token', path: '/recuperar/validar-token', critical: false },
    { name: 'üéâ Registration Success', path: '/registro-exitoso', critical: false },
    
    // Funcionalidades principales
    { name: 'üìã Cotizador', path: '/cotizador', critical: true },
    { name: 'üì¶ Resumen', path: '/resumen', critical: true },
    { name: 'üë§ Remitente Edit', path: '/remitente/edit', critical: true },
    { name: 'üìç Destinatario', path: '/destinatario', critical: true },
    { name: 'üìä Mis Env√≠os', path: '/misenvios', critical: true },
    { name: 'üìû Contacto', path: '/contacto', critical: true },
    
    // Panel administrativo
    { name: 'üë• Admin Usuarios', path: '/admin/usuarios', critical: true },
    { name: 'üì¨ Admin Contactos', path: '/admin/contactos', critical: false },
    { name: 'üì¶ Admin Env√≠os', path: '/admin/envios', critical: false },
    
    // Mercado Pago
    { name: 'üí≥ Mercado Pago', path: '/mercadopago', critical: true },
    { name: 'üìä MP Status Brick', path: '/mercadopago/statusbrick', critical: false },
    { name: 'üí∞ Pagos', path: '/pagos', critical: true },
    
    // P√°ginas informativas
    { name: 'üë§ Perfil Card', path: '/perfilCard', critical: false },
    { name: 'üìÑ T√©rminos', path: '/terminos', critical: false },
    { name: 'üîí Pol√≠tica de Datos', path: '/politica-datos', critical: false },
    
    // P√°ginas de diagn√≥stico y utilidad
    { name: 'üîß Diagnostic', path: '/diagnostic', critical: false },
    { name: 'üì± No Conexi√≥n', path: '/no-conexion', critical: false },
    { name: 'üéØ Test Ads', path: '/test-ads', critical: false },
    
    // APIs cr√≠ticas
    { name: 'üîê NextAuth Session', path: '/api/auth/session', critical: true, isAPI: true },
    { name: '‚ù§Ô∏è Health Check', path: '/api/health', critical: true, isAPI: true },
    { name: 'üåê Public Config', path: '/api/public/config', critical: false, isAPI: true },
    { name: 'üß™ Test API', path: '/api/test', critical: false, isAPI: true },
    { name: 'üìä Status API', path: '/api/status', critical: false, isAPI: true },
    
    // Google Auth
    { name: 'üîÑ Google Callback', path: '/auth/google/callback', critical: true },
    { name: 'üì± Native Finalize', path: '/auth/native-finalize', critical: false },
    
    // Assets est√°ticos
    { name: 'üé® Favicon', path: '/favicon.ico', critical: false, isStatic: true },
];

async function runComprehensiveTest() {
    console.log('üîç TEST COMPLETO DE TODAS LAS RUTAS');
    console.log('=' .repeat(70));
    console.log(`üåê URL: ${PRODUCTION_URL}`);
    console.log(`‚è∞ Timestamp: ${new Date().toISOString()}`);
    console.log(`üìä Total rutas a probar: ${routes.length}`);
    console.log('');

    const results = [];
    let passedTests = 0;
    let criticalPassed = 0;
    let criticalTotal = routes.filter(r => r.critical).length;
    
    for (const route of routes) {
        try {
            console.log(`üß™ ${route.name}...`);
            const response = await makeRequest(PRODUCTION_URL, route.path, true);
            
            // Determinar si el test pas√≥
            let passed = false;
            let reason = '';
            
            if (route.isAPI) {
                // Para APIs, 200 es √©xito, 401/403 puede ser normal para endpoints protegidos
                passed = response.status === 200 || response.status === 401 || response.status === 403;
                if (!passed) reason = `API returned ${response.status}`;
            } else if (route.isStatic) {
                // Para archivos est√°ticos, solo 200 es √©xito
                passed = response.status === 200;
                if (!passed) reason = `Static file not found (${response.status})`;
            } else {
                // Para p√°ginas, 200 es √©xito, redirecciones pueden ser normales
                passed = response.status === 200 || 
                        (response.redirected && response.status === 200) ||
                        response.status === 302 || response.status === 307;
                
                // Verificar que no hay errores de SSR
                if (passed && response.data) {
                    const hasSSRError = response.data.includes('Cannot read properties of null') ||
                                      response.data.includes('useContext') && response.data.includes('null');
                    if (hasSSRError) {
                        passed = false;
                        reason = 'SSR error detected';
                    }
                }
                
                if (!passed && !reason) {
                    reason = `Page error (${response.status})`;
                }
            }
            
            results.push({
                name: route.name,
                path: route.path,
                passed,
                critical: route.critical,
                status: response.status,
                originalStatus: response.originalStatus,
                redirected: response.redirected,
                redirectUrl: response.redirectUrl,
                isAPI: route.isAPI,
                isStatic: route.isStatic,
                reason: reason,
                hasSSRErrors: response.data ? response.data.includes('Cannot read properties of null') : false
            });
            
            if (passed) {
                passedTests++;
                if (route.critical) criticalPassed++;
                
                let statusText = `Status: ${response.status}`;
                if (response.redirected) {
                    statusText += ` (redirected from ${response.originalStatus})`;
                }
                console.log(`   ‚úÖ PASS - ${statusText}`);
            } else {
                if (route.critical) {
                    console.log(`   üö® CRITICAL FAIL - ${reason}`);
                } else {
                    console.log(`   ‚ùå FAIL - ${reason}`);
                }
            }
            
        } catch (error) {
            results.push({
                name: route.name,
                path: route.path,
                passed: false,
                critical: route.critical,
                error: error.message,
                isAPI: route.isAPI,
                isStatic: route.isStatic
            });
            
            if (route.critical) {
                console.log(`   üö® CRITICAL ERROR: ${error.message}`);
            } else {
                console.log(`   üí• ERROR: ${error.message}`);
            }
        }
        
        // Pausa peque√±a entre requests para no sobrecargar el servidor
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log('');
    console.log('üìä RESUMEN FINAL COMPLETO');
    console.log('=' .repeat(70));
    
    const total = routes.length;
    const failedTests = total - passedTests;
    const criticalFailed = criticalTotal - criticalPassed;
    
    console.log(`‚úÖ Tests Exitosos: ${passedTests}/${total} (${Math.round(passedTests/total*100)}%)`);
    console.log(`‚ùå Tests Fallidos: ${failedTests}/${total} (${Math.round(failedTests/total*100)}%)`);
    console.log('');
    console.log(`üö® Funcionalidades Cr√≠ticas: ${criticalPassed}/${criticalTotal} (${Math.round(criticalPassed/criticalTotal*100)}%)`);
    
    if (criticalFailed > 0) {
        console.log(`‚ö†Ô∏è  ${criticalFailed} funcionalidades cr√≠ticas fallaron`);
    }
    
    // Verificar errores espec√≠ficos
    const ssrErrors = results.filter(r => r.hasSSRErrors).length;
    if (ssrErrors > 0) {
        console.log(`üö® P√°ginas con errores SSR: ${ssrErrors}/${total}`);
    } else {
        console.log('‚ú® Sin errores SSR detectados');
    }
    
    // An√°lisis por categor√≠as
    const apiResults = results.filter(r => r.isAPI);
    const pageResults = results.filter(r => !r.isAPI && !r.isStatic);
    const staticResults = results.filter(r => r.isStatic);
    
    console.log('');
    console.log('üìà AN√ÅLISIS POR CATEGOR√çAS:');
    console.log(`   üìÑ P√°ginas: ${pageResults.filter(r => r.passed).length}/${pageResults.length} funcionando`);
    console.log(`   üîå APIs: ${apiResults.filter(r => r.passed).length}/${apiResults.length} funcionando`);
    console.log(`   üé® Assets: ${staticResults.filter(r => r.passed).length}/${staticResults.length} funcionando`);
    
    // Estado general
    if (criticalPassed === criticalTotal && passedTests > total * 0.9) {
        console.log('');
        console.log('üéâ ¬°SITIO COMPLETAMENTE FUNCIONAL!');
        console.log('üöÄ Todas las funcionalidades cr√≠ticas operativas');
        console.log('üåü Deployment exitoso en producci√≥n');
        console.log('');
        console.log(`üîó Sitio: ${PRODUCTION_URL}`);
        console.log('üîó APIs: Netlify Functions configuradas');
        console.log('üîó Autenticaci√≥n: Google OAuth activa');
        console.log('üîó Pagos: MercadoPago integrado');
    } else if (criticalPassed === criticalTotal) {
        console.log('');
        console.log('‚ö° SITIO FUNCIONANDO CORRECTAMENTE');
        console.log('‚úÖ Funcionalidades cr√≠ticas operativas');
        console.log('üîß Algunas funciones secundarias pueden necesitar ajustes');
    } else {
        console.log('');
        console.log('üî¥ PROBLEMAS CR√çTICOS DETECTADOS');
        console.log('üõ†Ô∏è  Requiere intervenci√≥n inmediata');
        console.log('üìã Revisar funcionalidades cr√≠ticas fallidas');
    }
    
    // Guardar reporte detallado
    const report = {
        timestamp: new Date().toISOString(),
        url: PRODUCTION_URL,
        summary: {
            totalTests: total,
            passed: passedTests,
            failed: failedTests,
            successRate: Math.round(passedTests/total*100),
            criticalTotal: criticalTotal,
            criticalPassed: criticalPassed,
            criticalFailed: criticalFailed,
            criticalSuccessRate: Math.round(criticalPassed/criticalTotal*100),
            ssrErrorsDetected: ssrErrors,
            categoriesAnalysis: {
                pages: {
                    total: pageResults.length,
                    passed: pageResults.filter(r => r.passed).length
                },
                apis: {
                    total: apiResults.length,
                    passed: apiResults.filter(r => r.passed).length
                },
                assets: {
                    total: staticResults.length,
                    passed: staticResults.filter(r => r.passed).length
                }
            }
        },
        results: results,
        status: criticalPassed === criticalTotal && passedTests > total * 0.9 ? 'SUCCESS' : 
                criticalPassed === criticalTotal ? 'FUNCTIONAL' : 'CRITICAL_ISSUES'
    };
    
    fs.writeFileSync('COMPREHENSIVE_ROUTE_TEST_REPORT.json', JSON.stringify(report, null, 2));
    console.log('');
    console.log('üìù Reporte completo guardado en: COMPREHENSIVE_ROUTE_TEST_REPORT.json');
    
    // Mostrar rutas fallidas si las hay
    const failedRoutes = results.filter(r => !r.passed);
    if (failedRoutes.length > 0) {
        console.log('');
        console.log('‚ùå RUTAS CON PROBLEMAS:');
        failedRoutes.forEach(route => {
            const priority = route.critical ? 'üö® CR√çTICA' : '‚ö†Ô∏è  OPCIONAL';
            console.log(`   ${priority} ${route.name} (${route.path}) - ${route.reason || route.error}`);
        });
    }
}

// Ejecutar test completo
runComprehensiveTest().catch(console.error);
